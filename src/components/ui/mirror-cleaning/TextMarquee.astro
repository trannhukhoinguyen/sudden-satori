---
interface Props {
  texts: string[];
  direction?: 1 | -1;
  class?: string;
}

const { texts, direction, class: className = "" } = Astro.props;
---

<sy-text-marquee data-dir={direction} class:list={[className]}>
  <div class="outer">
    <div class="inner">
      {texts.map((t) => <div class="text">{t}</div>)}
    </div>
  </div>
</sy-text-marquee>

<style>
  sy-text-marquee {
    display: block;
    position: relative;
    overflow: hidden;
    width: 100vw;
    max-width: 100%;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    backdrop-filter: blur(6px) saturate(1.05);

    :global(&.is-ready) {
      opacity: 1;
    }
  }

  .outer {
    display: flex;
    transform: translateX(var(--x));
    will-change: transform;
  }

  .inner {
    display: flex;
    align-items: center;
    width: fit-content;
  }

  .text {
    @extend %u-text;
    --fs: 4rem;
    --fw: 600;

    white-space: nowrap;
    display: flex;
    align-items: center;
    -webkit-text-stroke-color: currentColor;
    -webkit-text-stroke-width: 2px;
    -webkit-text-fill-color: transparent;
    color: var(--c, var(--color-brand-1));

    &:before {
      display: block;
      margin: 0 0.35em;
      width: 0.2em;
      height: 0.2em;

      background: currentcolor;
      border-radius: 99px;

      content: "";
    }

    &:nth-child(odd) {
      -webkit-text-fill-color: unset;
    }
  }
</style>

<script>
  import { addResizeObserver } from "../utils/observers";
  import { addIntersectingTicker } from "../utils/globalTicker";

  class TextMarquee extends HTMLElement {
    x = 0;
    textWidth = -1;
    direction = 1;
    html: string;
    outerEl: HTMLElement;

    constructor() {
      super();

      this.direction = Number(this.dataset.dir) || 1;
      this.outerEl = this.querySelector(".outer") as HTMLElement;
      this.html = this.outerEl.innerHTML;
      this.x = Math.round(1000 * -this.direction * Math.random());

      addResizeObserver(this);
      addIntersectingTicker(this);
    }

    connectedCallback() {
      document.fonts.ready.then(() => {
        this.fill();
        this.classList.add("is-ready");
      });
    }

    onWidthResize() {
      this.fill();
    }

    fill() {
      const { html, outerEl } = this;

      outerEl.innerHTML = html;

      const bcr = outerEl.firstElementChild!.getBoundingClientRect();
      const width = window.innerWidth;

      if (!bcr.width) {
        return;
      }

      const repeats = Math.ceil(width / bcr.width) * 2;

      outerEl.innerHTML += html.repeat(repeats - 1);

      [...outerEl.children].forEach((el, i) => {
        if (i > 0) {
          el.ariaHidden = "true";
        }
      });

      this.textWidth = Math.round(outerEl.scrollWidth / 2);
    }

    tick() {
      const txtWidth = this.textWidth;
      let x = this.x;

      const dir = this.direction;
      x -=
        (Math.min(Math.abs(window.scrollVelocity) * 0.4, 10) + 0.5) *
        (window.scrollDirection || 1) *
        dir;

      if (x <= -txtWidth) {
        x = 0;
      } else if (x > 0) {
        x = -txtWidth;
      }

      this.style.setProperty("--x", `${x}px`);
      this.x = x;
    }
  }

  customElements.define("sy-text-marquee", TextMarquee);
</script>

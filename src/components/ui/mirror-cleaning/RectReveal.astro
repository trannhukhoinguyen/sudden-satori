---
interface Props {
  class?: string;
  ignoreLast?: boolean;
}

const { class: className, ignoreLast } = Astro.props;
---

<sy-rect-reveal class:list={className} data-ignore-last={ignoreLast}>
  <div class="inner">
    <slot />
  </div>
</sy-rect-reveal>

<style>
  sy-rect-reveal {
    display: block;
  }

  .inner {
    height: 300vh;
    display: grid;
    grid-template-columns: 1fr;
    grid-template-rows: 1fr;

    :global(> *) {
      grid-row: 1;
      grid-column: 1;
      will-change: clip-path;
      position: sticky;
      height: 100vh;
      top: 0;
    }
  }
</style>

<script>
  import gsap from "gsap";
  import ScrollTrigger from "gsap/ScrollTrigger";
  import { manualRevealIn } from "../utils/reveals";

  gsap.registerPlugin(ScrollTrigger);

  function rotateSquarePercent(
    angle: number,
    sizePercent: number,
    containerWidth: number,
    containerHeight: number,
  ) {
    const square = [
      { x: -0.5, y: -0.5 },
      { x: 0.5, y: -0.5 },
      { x: 0.5, y: 0.5 },
      { x: -0.5, y: 0.5 },
    ];

    const centerPercent = { x: 50, y: 50 };

    let angleRad = (angle * Math.PI) / 180;
    let cos = Math.cos(angleRad);
    let sin = Math.sin(angleRad);

    let sizeX =
      sizePercent *
      (containerWidth < containerHeight
        ? containerWidth / 100
        : containerHeight / 100);
    let sizeY = sizeX; // keep it square

    return square.map((p) => {
      let x = p.x * sizeX;
      let y = p.y * sizeY;

      let rotatedX = x * cos - y * sin;
      let rotatedY = x * sin + y * cos;

      return {
        x: centerPercent.x + (rotatedX / containerWidth) * 100,
        y: centerPercent.y + (rotatedY / containerHeight) * 100,
      };
    });
  }

  class RectReveal extends HTMLElement {
    connectedCallback() {
      const ignoreLast = this.dataset.ignoreLast === "true";
      const inner = this.querySelector<HTMLElement>(".inner")!;
      const initRotation = 35;
      const theta = (initRotation * Math.PI) / 180;
      const factor = Math.abs(Math.cos(theta)) + Math.abs(Math.sin(theta));

      const inners = this.querySelectorAll<HTMLElement>(".inner > *");
      const sizes = [0, 0];

      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: inner,
          // pin: true,
          scrub: true,
          start: "top top",
          end: () => `+=${window.innerHeight * 1.5}`,
          invalidateOnRefresh: true,
          onRefresh: () => {
            sizes[0] = window.innerWidth;
            sizes[1] = window.innerHeight;
          },
          // onUpdate: (st) => {
          //   this.style.setProperty("--rrp", `${st.progress}`);
          // },
        },
      });

      inners.forEach((el, i) => {
        const reveals = el.querySelectorAll<HTMLElement>(
          "[data-sy-reveal-manual]",
        );
        const p = {
          p: 0,
        };

        gsap.set(el, {
          zIndex: inners.length - i,
        });

        tl.add(
          () => {
            if (tl.scrollTrigger?.direction === 1) {
              reveals.forEach((r) => {
                manualRevealIn(r);
              });
            }
          },
          i === 0 ? 0 : ">-0.3",
        );

        if (ignoreLast && i === inners.length - 1) {
          return;
        }

        tl.fromTo(
          p,
          {
            p: 0,
          },
          {
            p: 1,
            onUpdate: () => {
              const progress = p.p;
              const [wWidth, wHeight] = sizes;

              const angle = initRotation + progress * 75;
              const maxSide = Math.max(wWidth, wHeight) * factor;

              const initialSizePercent =
                (maxSide / Math.min(wWidth, wHeight)) * 100;

              const sizePercent =
                initialSizePercent - progress * initialSizePercent;

              const rotated = rotateSquarePercent(
                angle,
                sizePercent,
                wWidth,
                wHeight,
              );

              const polygon = rotated.map((p) => `${p.x}% ${p.y}%`).join(", ");
              el.style.clipPath = `polygon(${polygon})`;
            },
          },
        );
      });
    }
  }

  customElements.define("sy-rect-reveal", RectReveal);
</script>

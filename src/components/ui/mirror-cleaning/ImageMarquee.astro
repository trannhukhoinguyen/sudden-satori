---
import type { Image } from "../types";

interface Props {
  images: Image[];
  direction?: 1 | -1;
}

const { images, direction } = Astro.props;
---

<sy-image-marquee data-dir={direction}>
  <div class="inner">
    {
      images.map((img) => (
        <div class="img">
          <img {...img} />
        </div>
      ))
    }
  </div>
</sy-image-marquee>

<style>
  sy-image-marquee {
    display: block;
    position: relative;
    overflow: hidden;
    width: 100%;
    padding: 0.75rem 0 4rem;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;

    :global(&.is-ready) {
      opacity: 1;
    }
  }

  .inner {
    display: grid;
    gap: 3rem;

    @media (--mq-tablet-sm) {
      gap: 1rem;
    }
  }

  .img {
    grid-row: 1;
    grid-column: 1;
    transform: translateZ(0);
    will-change: transform;
    width: 6rem;
    height: 3rem;

    @media (--mq-tablet-sm) {
      width: 10.9375rem;
      height: 5.5625rem;
    }

    img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  }
</style>

<script>
  import { addResizeObserver } from "../utils/observers";
  import { addIntersectingTicker } from "../utils/globalTicker";

  import { gsap } from "gsap";

  class ImageMarquee extends HTMLElement {
    x = 0;
    width = -1;
    direction = 1;
    ghosts: HTMLElement[] = [];
    images: HTMLElement[] = [];
    wrap!: (n: number) => number;

    constructor() {
      super();

      this.images = Array.from(this.querySelectorAll(".img")) as HTMLElement[];
      this.direction = Number(this.dataset.dir) || 1;

      addResizeObserver(this);
      addIntersectingTicker(this);
    }

    connectedCallback() {
      this.reCalc();

      this.classList.add("is-ready");
    }

    onWidthResize() {
      this.reCalc();
    }

    reCalc() {
      const { images } = this;

      const inner = this.querySelector(".inner")!;

      const fbcr = images[0].getBoundingClientRect();
      const gap = parseInt(window.getComputedStyle(inner).columnGap, 10);

      const width = Math.floor(fbcr.width + gap);

      this.width = width;

      this.fillScreen();

      this.wrap = gsap.utils.wrap(-width, width * (this.images.length - 1));

      this.x = Math.round(1000 * -this.direction * Math.random());
    }

    fillScreen() {
      const images = this.images;
      const width = this.width;
      const innerWidth = window.innerWidth * 2;
      const inner = this.querySelector(".inner")!;

      this.ghosts.forEach((g) => {
        const index = images.indexOf(g);
        images.splice(index, 1);

        g.remove();
      });

      this.ghosts = [];
      const ghosts = this.ghosts;

      const fillCount = Math.floor(innerWidth / width);

      if (images.length < fillCount) {
        for (let i = 0; i < fillCount - images.length; i++) {
          const clone = images[i % images.length].cloneNode(
            true,
          ) as HTMLElement;

          clone.ariaHidden = "true";
          ghosts.push(clone);
          images.push(clone);
        }

        inner.append(...ghosts);
      }

      this.images = images;
    }

    tick() {
      const dir = this.direction;

      this.x -=
        (Math.min(Math.abs(window.scrollVelocity) * 0.4, 10) + 0.5) *
        (window.scrollDirection || 1) *
        dir;

      const images = this.images;
      const width = this.width;
      const x = this.x;
      const wrap = this.wrap;

      images.forEach((item, i) => {
        const xx = wrap(x + width * i);

        item.style.transform = `translateX(${xx}px)`;
      });
    }
  }

  customElements.define("sy-image-marquee", ImageMarquee);
</script>
